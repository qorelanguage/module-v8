#!/usr/bin/env qore

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires v8
%requires QUnit
%requires Util

%exec-class V8Test

class V8Test inherits Test {
    public {
    }

    constructor() : Test("v8 test", "1.0") {
        addTestCase("v8 program test", \v8ProgramTest());
        addTestCase("exception test", \v8ExceptionTest());
        # Set return value for compatibility with test harnesses that check the return value
        set_return_value(main());
    }

    v8ProgramTest() {
        JavaScriptProgram js("'hi'", "test.js");
        assertEq("hi", js.run());

        js = new JavaScriptProgram("1", "test.js");
        assertEq(1, js.run());

        js = new JavaScriptProgram("1.1", "test.js");
        assertEq(1.1, js.run());

        js = new JavaScriptProgram("true", "test.js");
        assertEq(True, js.run());

        js = new JavaScriptProgram("false", "test.js");
        assertEq(False, js.run());

        js = new JavaScriptProgram("[0, 'one', 2.1]", "test.js");
        assertEq((0, "one", 2.1), js.run());

        JavaScriptObject o(js);
        assertEq("JavaScriptObject", o.className());

        delete js;
        assertEq("JavaScriptObject", o.className());

        js = new JavaScriptProgram("
var foo = function(arg) {
    return arg + 1;
}", "test.js");
        js.run();
        JavaScriptObject global = js.getGlobal();
        auto foo = global.getKeyValue("foo");
        assertEq(NT_OBJECT, foo.typeCode());
        assertEq("JavaScriptObject", foo.className());
        assertTrue(foo.isCallable());
        assertEq(2, foo.callAsFunction(global, 1));

        js = new JavaScriptProgram("const obj = {
    id: 1,
    type: 't',
    func: function(a) {
        ++this.id;
        return a + 1;
    }
};
obj", "test.js");
        o = js.run();
        assertEq(NT_OBJECT, o.typeCode());
        assertEq("JavaScriptObject", o.className());
        hash<auto> h = o.toHash();
        assertEq({"id": 1, "type": "t"}, h - "func");
        assertTrue(h.func.isCallable());
        assertEq(1, o.getKeyValue("id"));
        h.func.callAsFunction(o, 1);
        assertEq(2, o.getKeyValue("id"));
        assertEq(2, h.func.callAsFunction(o, 1));
        assertEq(3, o.getKeyValue("id"));
        assertThrows("JAVASCRIPT-PROGRAM-ERROR", \h.func.callAsFunction(), (global, 1));

        js = new JavaScriptProgram("const obj = {
    func: function(a, b) {
        return typeof a;
    }
};
obj", "test.js");
        o = js.run();
        global = js.getGlobal();
        assertEq(NT_OBJECT, o.typeCode());
        assertEq("JavaScriptObject", o.className());
        h = o.toHash();
        assertTrue(h.func.isCallable());
        code c = int sub (int i) {
            return i + 1;
        };
        assertEq("function", h.func.callAsFunction(global, c, 1));

        js = new JavaScriptProgram("const obj = {
    func: function(a, b) {
        return a(b);
    }
};
obj", "test.js");
        o = js.run();
        global = js.getGlobal();
        assertEq(NT_OBJECT, o.typeCode());
        assertEq("JavaScriptObject", o.className());
        h = o.toHash();
        assertTrue(h.func.isCallable());
        assertEq(2, h.func.callAsFunction(global, c, 1));

        js = new JavaScriptProgram("const obj = {
    func: function(a, b) {
        return a.a(b);
    },
    func0: function(a) {
        return JSON.stringify(a);
    }
};
obj", "test.js");
        o = js.run();
        global = js.getGlobal();
        assertEq(NT_OBJECT, o.typeCode());
        assertEq("JavaScriptObject", o.className());
        h = o.toHash();
        assertTrue(h.func.isCallable());
        hash<auto> obj = {
            "a": c,
        };
        assertEq(2, o.func(obj, 1));
        assertEq(2, h.func.callAsFunction(global, obj, 1));

        js = new JavaScriptProgram("const obj = {
    func: null,
    store: function(a) {
        this.func = a;
    }
};
obj", "test.js");
        o = js.run();
        assertEq(NT_OBJECT, o.typeCode());
        assertEq("JavaScriptObject", o.className());
        h = o.toHash();
        assertNothing(h.func);
        assertTrue(h.store.isCallable());
        h.store.callAsFunction(o, int sub (int i) {
            return i + 1;
        });
        h = o.toHash();
        assertTrue(h.func.isCallable());
        assertEq(2, h.func.callAsFunction(o, 1));
        assertThrows("JAVASCRIPT-PROGRAM-ERROR", \h.func.callAsFunction(), (global, 1));
    }

    v8ExceptionTest() {
        hash<ExceptionInfo> ex;
        try {
            JavaScriptProgram js("const obj = {
    func1: function(a, b) {
        return a.a(b);
    },
    func0: function(a, b) {
        return this.func1(a, b);
    }
};
obj", "test.js");
            JavaScriptObject o = js.run();
            o.toHash().func0.callAsFunction(o, 1, 1);
            assertFalse(True);
        } catch (hash<ExceptionInfo> ex0) {
            ex = ex0;
        }
        on_error printf("source exception: %s\n", get_exception_string(ex));
        assertEq("Object.func1", ex.callstack[0].function);
        assertEq(3, ex.callstack[0].line);
        assertEq("Object.func0", ex.callstack[1].function);
        assertEq(6, ex.callstack[1].line);
    }
}
